#
# See https://docs.microsoft.com/en-us/vsts/pipelines/yaml-schema for details on this file.
#

# Configure which branches trigger builds
trigger:
  batch: true
  branches:
    include:
    - main
    - release/*
    - internal/release/*

# Run PR validation on all branches
pr:
  autoCancel: true
  branches:
    include:
    - '*'

variables:
- name: DOTNET_SKIP_FIRST_TIME_EXPERIENCE
  value: true
- name: _TeamName
  value:  AspNetCore
- name: _DotNetPublishToBlobFeed
  value: true
- name: _PublishUsingPipelines
  value: true
- name: _DotNetArtifactsCategory
  value: .NETCORE
- name: _DotNetValidationArtifactsCategory
  value: .NETCORE
- name: PostBuildSign
  value: true
# Write binary logs for all main Windows build steps except the x86 one
- name: Windows64LogArgs
  value: /bl:artifacts/log/Release/Build.x64.binlog
- name: Windows86LogArgs
  value: -ExcludeCIBinaryLog
- name: WindowsSignLogArgs
  value: /bl:artifacts/log/Release/Build.CodeSign.binlog
- name: WindowsInstallersLogArgs
  value: /bl:artifacts/log/Release/Build.Installers.binlog
- ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
  - name: _BuildArgs
    value: /p:TeamName=$(_TeamName)
           /p:OfficialBuildId=$(Build.BuildNumber)
           /p:SkipTestBuild=true
           /p:PostBuildSign=$(PostBuildSign)
  # DotNet-Blob-Feed provides: dotnetfeed-storage-access-key-1
  # Publish-Build-Assets provides: MaestroAccessToken, BotAccount-dotnet-maestro-bot-PAT
  - group: DotNet-Blob-Feed
  - group: Publish-Build-Assets
  # The following extra properties are not set when testing. Use with final build.[cmd,sh] of asset-producing jobs.
  - name: _PublishArgs
    value: /p:Publish=true
           /p:GenerateChecksums=true
           /p:DotNetPublishBlobFeedKey=$(dotnetfeed-storage-access-key-1)
           /p:DotNetPublishBlobFeedUrl=https://dotnetfeed.blob.core.windows.net/dotnet-core/index.json
           /p:DotNetPublishToBlobFeed=$(_DotNetPublishToBlobFeed)
           /p:DotNetPublishUsingPipelines=$(_PublishUsingPipelines)
           /p:DotNetArtifactsCategory=$(_DotNetArtifactsCategory)
- ${{ if or(eq(variables['System.TeamProject'], 'public'), in(variables['Build.Reason'], 'PullRequest')) }}:
  - name: _BuildArgs
    value: '/p:SkipTestBuild=true /p:PostBuildSign=$(PostBuildSign)'
  - name: _PublishArgs
    value: ''
- ${{ if ne(variables['System.TeamProject'], 'internal') }}:
  - name: _UseHelixOpenQueues
    value: 'true'
  - name: _SignType
    value: ''
  - name: _InternalRuntimeDownloadArgs
    value: ''
  - name: _InternalRuntimeDownloadCodeSignArgs
    value: ''
- ${{ if eq(variables['System.TeamProject'], 'internal') }}:
  - group: DotNet-MSRC-Storage
  - name: _InternalRuntimeDownloadArgs
    value: -RuntimeSourceFeed https://dotnetclimsrc.blob.core.windows.net/dotnet
           -RuntimeSourceFeedKey $(dotnetclimsrc-read-sas-token-base64)
           /p:DotNetAssetRootAccessTokenSuffix='$(dotnetclimsrc-read-sas-token-base64)'
  # The code signing doesn't use the aspnet build scripts, so the msbuild parameters have to be passed directly. This
  # is awkward but necessary because the eng/common/ build scripts don't add the msbuild properties automatically.
  - name: _InternalRuntimeDownloadCodeSignArgs
    value: $(_InternalRuntimeDownloadArgs)
           /p:DotNetRuntimeSourceFeed=https://dotnetclimsrc.blob.core.windows.net/dotnet
           /p:DotNetRuntimeSourceFeedKey=$(dotnetclimsrc-read-sas-token-base64)
  - group: DotNet-HelixApi-Access
  - name: _UseHelixOpenQueues
    value: 'false'
  - ${{ if notin(variables['Build.Reason'], 'PullRequest') }}:
    - name: _SignType
      value: real
  - ${{ if in(variables['Build.Reason'], 'PullRequest') }}:
    - name: _SignType
      value: test

stages:
- stage: build
  displayName: Build
  jobs:
  # Build Windows (x64/x86)
  - template: jobs/default-build.yml
    parameters:
      codeSign: true
      jobName: Windows_build
      jobDisplayName: "Build: Windows x64/x86"
      agentOs: Windows
      steps:
      - script: "echo ##vso[build.addbuildtag]daily-build"
        condition: and(notin(variables['Build.Reason'], 'PullRequest'), notin(variables['DotNetFinalVersionKind'], 'release', 'prerelease'))
        displayName: 'Set CI tags'
      - script: "echo ##vso[build.addbuildtag]release-candidate"
        condition: and(notin(variables['Build.Reason'], 'PullRequest'), in(variables['DotNetFinalVersionKind'], 'release', 'prerelease'))
        displayName: 'Set CI tags'

      # !!! NOTE !!! Some of these steps have disabled code signing.
      # This is intentional to workaround https://github.com/dotnet/arcade/issues/1957 which always re-submits for code-signing, even
      # if they have already been signed. This results in slower builds due to re-submitting the same .nupkg many times for signing.
      # The sign settings have been configured to
      - script: ./eng/build.cmd
                -ci
                -arch x64
                -pack
                -all
                $(_BuildArgs)
                $(_InternalRuntimeDownloadArgs)
                $(Windows64LogArgs)
        displayName: Build x64

      # Build the x86 shared framework
      # This is going to actually build x86 native assets.
      - script: ./eng/build.cmd
                -ci
                -noBuildRepoTasks
                -arch x86
                -pack
                -all
                -noBuildJava
                -noBuildNative
                /p:OnlyPackPlatformSpecificPackages=true
                $(_BuildArgs)
                $(_InternalRuntimeDownloadArgs)
                $(Windows86LogArgs)
        displayName: Build x86

      - script: .\src\SiteExtensions\build.cmd
                -ci
                -noBuildRepoTasks
                -pack
                -noBuildDeps
                -noBuildNative
                $(_BuildArgs)
                $(_InternalRuntimeDownloadArgs)
        condition: ne(variables['Build.Reason'], 'PullRequest')
        displayName: Build SiteExtension

      # This runs code-signing on all packages, zips, and jar files as defined in build/CodeSign.targets. If
      # https://github.com/dotnet/arcade/issues/1957 is resolved, consider running code-signing inline with the other
      # previous steps. Sign check is disabled because it is run in a separate step below, after installers are built.
      - script: ./eng/build.cmd
                -ci
                -noBuildRepoTasks
                -noBuildNative
                -noBuild
                -noRestore
                -sign
                /p:DotNetSignType=$(_SignType)
                $(_BuildArgs)
                $(WindowsSignLogArgs)
        displayName: Code sign packages

      # Windows installers bundle both x86 and x64 assets
      - script: ./eng/build.cmd
                -ci
                -noBuildRepoTasks
                -sign
                -buildInstallers
                -noBuildNative
                /p:DotNetSignType=$(_SignType)
                /p:AssetManifestFileName=aspnetcore-win-x64-x86.xml
                $(_BuildArgs)
                $(_PublishArgs)
                $(_InternalRuntimeDownloadArgs)
                /p:PublishInstallerBaseVersion=true
                $(WindowsInstallersLogArgs)
        displayName: Build Installers

      # A few files must also go to the VS package feed.
      - ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest'), ne(variables['PostBuildSign'], 'true')) }}:
        - task: NuGetCommand@2
          displayName: Push Visual Studio packages
          inputs:
            command: push
            packagesToPush: 'artifacts/packages/**/VS.Redist.Common.AspNetCore.*.nupkg'
            nuGetFeedType: external
            publishFeedCredentials: 'DevDiv - VS package feed'

      artifacts:
      - name: Windows_Logs
        path: artifacts/log/
        publishOnError: true
        includeForks: true
      - name: Windows_Packages
        path: artifacts/packages/
